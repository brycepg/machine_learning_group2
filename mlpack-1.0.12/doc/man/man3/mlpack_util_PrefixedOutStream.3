.TH "mlpack::util::PrefixedOutStream" 3 "Sat Mar 14 2015" "Version 1.0.12" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::util::PrefixedOutStream \- 
.PP
Allows us to output to an ostream with a prefix at the beginning of each line, in the same way we would output to cout or cerr\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPrefixedOutStream\fP (std::ostream &\fBdestination\fP, const char *\fBprefix\fP, bool \fBignoreInput\fP=false, bool \fBfatal\fP=false)"
.br
.RI "\fISet up the \fBPrefixedOutStream\fP\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (bool val)"
.br
.RI "\fIWrite a bool to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (short val)"
.br
.RI "\fIWrite a short to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (unsigned short val)"
.br
.RI "\fIWrite an unsigned short to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (int val)"
.br
.RI "\fIWrite an int to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (unsigned int val)"
.br
.RI "\fIWrite an unsigned int to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (long val)"
.br
.RI "\fIWrite a long to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (unsigned long val)"
.br
.RI "\fIWrite an unsigned long to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (float val)"
.br
.RI "\fIWrite a float to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (double val)"
.br
.RI "\fIWrite a double to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (long double val)"
.br
.RI "\fIWrite a long double to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (void *val)"
.br
.RI "\fIWrite a void pointer to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (const char *str)"
.br
.RI "\fIWrite a character array to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (std::string &str)"
.br
.RI "\fIWrite a string to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (std::streambuf *sb)"
.br
.RI "\fIWrite a streambuf to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (std::ostream &(*pf)(std::ostream &))"
.br
.RI "\fIWrite an ostream manipulator function to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (std::ios &(*pf)(std::ios &))"
.br
.RI "\fIWrite an ios manipulator function to the stream\&. \fP"
.ti -1c
.RI "\fBPrefixedOutStream\fP & \fBoperator<<\fP (std::ios_base &(*pf)(std::ios_base &))"
.br
.RI "\fIWrite an ios_base manipulator function to the stream\&. \fP"
.ti -1c
.RI "template<typename T > \fBPrefixedOutStream\fP & \fBoperator<<\fP (const T &s)"
.br
.RI "\fIWrite anything else to the stream\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::ostream & \fBdestination\fP"
.br
.RI "\fIThe output stream that all data is to be sent too; example: std::cout\&. \fP"
.ti -1c
.RI "bool \fBignoreInput\fP"
.br
.RI "\fIDiscards input, prints nothing if true\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "template<typename T > void \fBBaseLogic\fP (const T &val)"
.br
.RI "\fIConducts the base logic required in all the operator << overloads\&. \fP"
.ti -1c
.RI "template<typename T > void \fBCallBaseLogic\fP (const T &s, typename boost::disable_if< boost::is_class< T > >::type *=0)"
.br
.RI "\fIThis handles forwarding all primitive types transparently\&. \fP"
.ti -1c
.RI "template<typename T > void \fBCallBaseLogic\fP (const T &s, typename boost::enable_if< boost::is_class< T > >::type *=0, typename boost::disable_if< HasToString< T, std::string(T::*)() const  > >::type *=0)"
.br
.RI "\fIForward all objects that do not implement a ToString() method\&. \fP"
.ti -1c
.RI "template<typename T > void \fBCallBaseLogic\fP (const T &s, typename boost::enable_if< boost::is_class< T > >::type *=0, typename boost::enable_if< HasToString< T, std::string(T::*)() const  > >::type *=0)"
.br
.RI "\fICall ToString() on all objects that implement ToString() before forwarding\&. \fP"
.ti -1c
.RI "void \fBPrefixIfNeeded\fP ()"
.br
.RI "\fIOutput the prefix, but only if we need to and if we are allowed to\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBcarriageReturned\fP"
.br
.RI "\fIIf true, the previous call to operator<< encountered a CR, and a prefix will be necessary\&. \fP"
.ti -1c
.RI "bool \fBfatal\fP"
.br
.RI "\fIIf true, the application will terminate with an error code when a CR is encountered\&. \fP"
.ti -1c
.RI "std::string \fBprefix\fP"
.br
.RI "\fIContains the prefix we must prepend to each line\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Allows us to output to an ostream with a prefix at the beginning of each line, in the same way we would output to cout or cerr\&. 

The prefix is specified in the constructor (as well as the destination ostream)\&. A newline must be passed to the stream, and then the prefix will be prepended to the next line\&. For example,
.PP
.PP
.nf
PrefixedOutStream outstr(std::cout, "[TEST] ");
outstr << "Hello world I like " << 7\&.5;
outstr << "\&.\&.\&.Continue" << std::endl;
outstr << "After the CR\n" << std::endl;
.fi
.PP
.PP
would give, on std::cout,
.PP
.PP
.nf
[TEST] Hello world I like 7\&.5\&.\&.\&.Continue
[TEST] After the CR
[TEST]
.fi
.PP
.PP
These objects are used for the \fBmlpack::Log\fP levels (DEBUG, INFO, WARN, and FATAL)\&. 
.PP
Definition at line 58 of file prefixedoutstream\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mlpack::util::PrefixedOutStream::PrefixedOutStream (std::ostream &destination, const char *prefix, boolignoreInput = \fCfalse\fP, boolfatal = \fCfalse\fP)\fC [inline]\fP"

.PP
Set up the \fBPrefixedOutStream\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdestination\fP ostream which receives output from this object\&. 
.br
\fIprefix\fP The prefix to prepend to each line\&. 
.RE
.PP

.PP
Definition at line 67 of file prefixedoutstream\&.hpp\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > void mlpack::util::PrefixedOutStream::BaseLogic (const T &val)\fC [private]\fP"

.PP
Conducts the base logic required in all the operator << overloads\&. Mostly just a good idea to reduce copy-pasta\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIT\fP The type of the data to output\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIval\fP The The data to be output\&. 
.RE
.PP

.SS "template<typename T > void mlpack::util::PrefixedOutStream::CallBaseLogic (const T &s, typename boost::disable_if< boost::is_class< T > >::type * = \fC0\fP)\fC [private]\fP"

.PP
This handles forwarding all primitive types transparently\&. 
.SS "template<typename T > void mlpack::util::PrefixedOutStream::CallBaseLogic (const T &s, typename boost::enable_if< boost::is_class< T > >::type * = \fC0\fP, typename boost::disable_if< HasToString< T, std::string(T::*)() const  > >::type * = \fC0\fP)\fC [private]\fP"

.PP
Forward all objects that do not implement a ToString() method\&. 
.SS "template<typename T > void mlpack::util::PrefixedOutStream::CallBaseLogic (const T &s, typename boost::enable_if< boost::is_class< T > >::type * = \fC0\fP, typename boost::enable_if< HasToString< T, std::string(T::*)() const  > >::type * = \fC0\fP)\fC [private]\fP"

.PP
Call ToString() on all objects that implement ToString() before forwarding\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (boolval)"

.PP
Write a bool to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (shortval)"

.PP
Write a short to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (unsigned shortval)"

.PP
Write an unsigned short to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (intval)"

.PP
Write an int to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (unsigned intval)"

.PP
Write an unsigned int to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (longval)"

.PP
Write a long to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (unsigned longval)"

.PP
Write an unsigned long to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (floatval)"

.PP
Write a float to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (doubleval)"

.PP
Write a double to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (long doubleval)"

.PP
Write a long double to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (void *val)"

.PP
Write a void pointer to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (const char *str)"

.PP
Write a character array to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (std::string &str)"

.PP
Write a string to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (std::streambuf *sb)"

.PP
Write a streambuf to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (std::ostream &(*)(std::ostream &)pf)"

.PP
Write an ostream manipulator function to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (std::ios &(*)(std::ios &)pf)"

.PP
Write an ios manipulator function to the stream\&. 
.SS "\fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (std::ios_base &(*)(std::ios_base &)pf)"

.PP
Write an ios_base manipulator function to the stream\&. 
.SS "template<typename T > \fBPrefixedOutStream\fP& mlpack::util::PrefixedOutStream::operator<< (const T &s)"

.PP
Write anything else to the stream\&. 
.SS "void mlpack::util::PrefixedOutStream::PrefixIfNeeded ()\fC [inline]\fP, \fC [private]\fP"

.PP
Output the prefix, but only if we need to and if we are allowed to\&. 
.SH "Member Data Documentation"
.PP 
.SS "bool mlpack::util::PrefixedOutStream::carriageReturned\fC [private]\fP"

.PP
If true, the previous call to operator<< encountered a CR, and a prefix will be necessary\&. 
.PP
Definition at line 175 of file prefixedoutstream\&.hpp\&.
.SS "std::ostream& mlpack::util::PrefixedOutStream::destination"

.PP
The output stream that all data is to be sent too; example: std::cout\&. 
.PP
Definition at line 120 of file prefixedoutstream\&.hpp\&.
.SS "bool mlpack::util::PrefixedOutStream::fatal\fC [private]\fP"

.PP
If true, the application will terminate with an error code when a CR is encountered\&. 
.PP
Definition at line 179 of file prefixedoutstream\&.hpp\&.
.SS "bool mlpack::util::PrefixedOutStream::ignoreInput"

.PP
Discards input, prints nothing if true\&. 
.PP
Definition at line 123 of file prefixedoutstream\&.hpp\&.
.SS "std::string mlpack::util::PrefixedOutStream::prefix\fC [private]\fP"

.PP
Contains the prefix we must prepend to each line\&. 
.PP
Definition at line 171 of file prefixedoutstream\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
