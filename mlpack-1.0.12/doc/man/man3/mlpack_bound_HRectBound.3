.TH "mlpack::bound::HRectBound< Power, TakeRoot >" 3 "Sat Mar 14 2015" "Version 1.0.12" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::bound::HRectBound< Power, TakeRoot > \- 
.PP
Hyper-rectangle bound for an L-metric\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBmetric::LMetric\fP< Power, 
.br
TakeRoot > \fBMetricType\fP"
.br
.RI "\fIThis is the metric type that this bound is using\&. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBHRectBound\fP ()"
.br
.RI "\fIEmpty constructor; creates a bound of dimensionality 0\&. \fP"
.ti -1c
.RI "\fBHRectBound\fP (const size_t dimension)"
.br
.RI "\fIInitializes to specified dimensionality with each dimension the empty set\&. \fP"
.ti -1c
.RI "\fBHRectBound\fP (const \fBHRectBound\fP &other)"
.br
.RI "\fICopy constructor; necessary to prevent memory leaks\&. \fP"
.ti -1c
.RI "\fB~HRectBound\fP ()"
.br
.RI "\fIDestructor: clean up memory\&. \fP"
.ti -1c
.RI "void \fBCentroid\fP (arma::vec &centroid) const "
.br
.RI "\fICalculates the centroid of the range, placing it into the given vector\&. \fP"
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "\fIResets all dimensions to the empty set (so that this bound contains nothing)\&. \fP"
.ti -1c
.RI "template<typename VecType > bool \fBContains\fP (const VecType &point) const "
.br
.RI "\fIDetermines if a point is within this bound\&. \fP"
.ti -1c
.RI "double \fBDiameter\fP () const "
.br
.RI "\fIReturns the diameter of the hyperrectangle (that is, the longest diagonal)\&. \fP"
.ti -1c
.RI "size_t \fBDim\fP () const "
.br
.RI "\fIGets the dimensionality\&. \fP"
.ti -1c
.RI "template<typename VecType > double \fBMaxDistance\fP (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > *=0) const "
.br
.RI "\fICalculates maximum bound-to-point squared distance\&. \fP"
.ti -1c
.RI "double \fBMaxDistance\fP (const \fBHRectBound\fP &other) const "
.br
.RI "\fIComputes maximum distance\&. \fP"
.ti -1c
.RI "template<typename VecType > double \fBMinDistance\fP (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > *=0) const "
.br
.RI "\fICalculates minimum bound-to-point distance\&. \fP"
.ti -1c
.RI "double \fBMinDistance\fP (const \fBHRectBound\fP &other) const "
.br
.RI "\fICalculates minimum bound-to-bound distance\&. \fP"
.ti -1c
.RI "double \fBMinWidth\fP () const "
.br
.RI "\fIGet the minimum width of the bound\&. \fP"
.ti -1c
.RI "double & \fBMinWidth\fP ()"
.br
.RI "\fIModify the minimum width of the bound\&. \fP"
.ti -1c
.RI "\fBHRectBound\fP & \fBoperator=\fP (const \fBHRectBound\fP &other)"
.br
.RI "\fISame as copy constructor; necessary to prevent memory leaks\&. \fP"
.ti -1c
.RI "\fBmath::Range\fP & \fBoperator[]\fP (const size_t i)"
.br
.RI "\fIGet the range for a particular dimension\&. \fP"
.ti -1c
.RI "const \fBmath::Range\fP & \fBoperator[]\fP (const size_t i) const "
.br
.RI "\fIModify the range for a particular dimension\&. No bounds checking\&. \fP"
.ti -1c
.RI "template<typename MatType > \fBHRectBound\fP & \fBoperator|=\fP (const MatType &data)"
.br
.RI "\fIExpands this region to include new points\&. \fP"
.ti -1c
.RI "\fBHRectBound\fP & \fBoperator|=\fP (const \fBHRectBound\fP &other)"
.br
.RI "\fIExpands this region to encompass another bound\&. \fP"
.ti -1c
.RI "\fBmath::Range\fP \fBRangeDistance\fP (const \fBHRectBound\fP &other) const "
.br
.RI "\fICalculates minimum and maximum bound-to-bound distance\&. \fP"
.ti -1c
.RI "template<typename VecType > \fBmath::Range\fP \fBRangeDistance\fP (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > *=0) const "
.br
.RI "\fICalculates minimum and maximum bound-to-point distance\&. \fP"
.ti -1c
.RI "std::string \fBToString\fP () const "
.br
.RI "\fIReturns a string representation of this object\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBMetricType\fP \fBMetric\fP ()"
.br
.RI "\fIReturn the metric associated with this bound\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBmath::Range\fP * \fBbounds\fP"
.br
.RI "\fIThe bounds for each dimension\&. \fP"
.ti -1c
.RI "size_t \fBdim\fP"
.br
.RI "\fIThe dimensionality of the bound\&. \fP"
.ti -1c
.RI "double \fBminWidth\fP"
.br
.RI "\fICached minimum width of bound\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<int Power = 2, bool TakeRoot = true>class mlpack::bound::HRectBound< Power, TakeRoot >"
Hyper-rectangle bound for an L-metric\&. 

This should be used in conjunction with the LMetric class\&. Be sure to use the same template parameters for LMetric as you do for \fBHRectBound\fP -- otherwise odd results may occur\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIPower\fP The metric to use; use 2 for Euclidean (L2)\&. 
.br
\fITakeRoot\fP Whether or not the root should be taken (see LMetric documentation)\&. 
.RE
.PP

.PP
Definition at line 36 of file hrectbound\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<int Power = 2, bool TakeRoot = true> typedef \fBmetric::LMetric\fP<Power, TakeRoot> \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::\fBMetricType\fP"

.PP
This is the metric type that this bound is using\&. 
.PP
Definition at line 40 of file hrectbound\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::\fBHRectBound\fP ()"

.PP
Empty constructor; creates a bound of dimensionality 0\&. 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::\fBHRectBound\fP (const size_tdimension)"

.PP
Initializes to specified dimensionality with each dimension the empty set\&. 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::\fBHRectBound\fP (const \fBHRectBound\fP< Power, TakeRoot > &other)"

.PP
Copy constructor; necessary to prevent memory leaks\&. 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::~\fBHRectBound\fP ()"

.PP
Destructor: clean up memory\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<int Power = 2, bool TakeRoot = true> void \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Centroid (arma::vec &centroid) const"

.PP
Calculates the centroid of the range, placing it into the given vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcentroid\fP Vector which the centroid will be written to\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> void \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Clear ()"

.PP
Resets all dimensions to the empty set (so that this bound contains nothing)\&. 
.SS "template<int Power = 2, bool TakeRoot = true> template<typename VecType > bool \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Contains (const VecType &point) const"

.PP
Determines if a point is within this bound\&. 
.SS "template<int Power = 2, bool TakeRoot = true> double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Diameter () const"

.PP
Returns the diameter of the hyperrectangle (that is, the longest diagonal)\&. 
.SS "template<int Power = 2, bool TakeRoot = true> size_t \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Dim () const\fC [inline]\fP"

.PP
Gets the dimensionality\&. 
.PP
Definition at line 68 of file hrectbound\&.hpp\&.
.PP
References mlpack::bound::HRectBound< Power, TakeRoot >::dim\&.
.SS "template<int Power = 2, bool TakeRoot = true> template<typename VecType > double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MaxDistance (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > * = \fC0\fP) const"

.PP
Calculates maximum bound-to-point squared distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP Point to which the maximum distance is requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MaxDistance (const \fBHRectBound\fP< Power, TakeRoot > &other) const"

.PP
Computes maximum distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Bound to which the maximum distance is requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> static \fBMetricType\fP \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::Metric ()\fC [inline]\fP, \fC [static]\fP"

.PP
Return the metric associated with this bound\&. Because it is an LMetric, it cannot store state, so we can make it on the fly\&. It is also static because the metric is only dependent on the template arguments\&. 
.PP
Definition at line 175 of file hrectbound\&.hpp\&.
.SS "template<int Power = 2, bool TakeRoot = true> template<typename VecType > double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MinDistance (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > * = \fC0\fP) const"

.PP
Calculates minimum bound-to-point distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP Point to which the minimum distance is requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MinDistance (const \fBHRectBound\fP< Power, TakeRoot > &other) const"

.PP
Calculates minimum bound-to-bound distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Bound to which the minimum distance is requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MinWidth () const\fC [inline]\fP"

.PP
Get the minimum width of the bound\&. 
.PP
Definition at line 77 of file hrectbound\&.hpp\&.
.PP
References mlpack::bound::HRectBound< Power, TakeRoot >::minWidth\&.
.SS "template<int Power = 2, bool TakeRoot = true> double& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::MinWidth ()\fC [inline]\fP"

.PP
Modify the minimum width of the bound\&. 
.PP
Definition at line 79 of file hrectbound\&.hpp\&.
.PP
References mlpack::bound::HRectBound< Power, TakeRoot >::minWidth\&.
.SS "template<int Power = 2, bool TakeRoot = true> \fBHRectBound\fP& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::operator= (const \fBHRectBound\fP< Power, TakeRoot > &other)"

.PP
Same as copy constructor; necessary to prevent memory leaks\&. 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmath::Range\fP& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::operator[] (const size_ti)\fC [inline]\fP"

.PP
Get the range for a particular dimension\&. No bounds checking\&. Be careful: this may make \fBMinWidth()\fP invalid\&. 
.PP
Definition at line 72 of file hrectbound\&.hpp\&.
.PP
References mlpack::bound::HRectBound< Power, TakeRoot >::bounds\&.
.SS "template<int Power = 2, bool TakeRoot = true> const \fBmath::Range\fP& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::operator[] (const size_ti) const\fC [inline]\fP"

.PP
Modify the range for a particular dimension\&. No bounds checking\&. 
.PP
Definition at line 74 of file hrectbound\&.hpp\&.
.PP
References mlpack::bound::HRectBound< Power, TakeRoot >::bounds\&.
.SS "template<int Power = 2, bool TakeRoot = true> template<typename MatType > \fBHRectBound\fP& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::operator|= (const MatType &data)"

.PP
Expands this region to include new points\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIMatType\fP Type of matrix; could be Mat, SpMat, a subview, or just a vector\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data points to expand this region to include\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> \fBHRectBound\fP& \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::operator|= (const \fBHRectBound\fP< Power, TakeRoot > &other)"

.PP
Expands this region to encompass another bound\&. 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmath::Range\fP \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::RangeDistance (const \fBHRectBound\fP< Power, TakeRoot > &other) const"

.PP
Calculates minimum and maximum bound-to-bound distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Bound to which the minimum and maximum distances are requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> template<typename VecType > \fBmath::Range\fP \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::RangeDistance (const VecType &point, typename boost::enable_if< \fBIsVector\fP< VecType > > * = \fC0\fP) const"

.PP
Calculates minimum and maximum bound-to-point distance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpoint\fP Point to which the minimum and maximum distances are requested\&. 
.RE
.PP

.SS "template<int Power = 2, bool TakeRoot = true> std::string \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::ToString () const"

.PP
Returns a string representation of this object\&. 
.SH "Member Data Documentation"
.PP 
.SS "template<int Power = 2, bool TakeRoot = true> \fBmath::Range\fP* \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::bounds\fC [private]\fP"

.PP
The bounds for each dimension\&. 
.PP
Definition at line 181 of file hrectbound\&.hpp\&.
.PP
Referenced by mlpack::bound::HRectBound< Power, TakeRoot >::operator[]()\&.
.SS "template<int Power = 2, bool TakeRoot = true> size_t \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::dim\fC [private]\fP"

.PP
The dimensionality of the bound\&. 
.PP
Definition at line 179 of file hrectbound\&.hpp\&.
.PP
Referenced by mlpack::bound::HRectBound< Power, TakeRoot >::Dim()\&.
.SS "template<int Power = 2, bool TakeRoot = true> double \fBmlpack::bound::HRectBound\fP< Power, TakeRoot >::minWidth\fC [private]\fP"

.PP
Cached minimum width of bound\&. 
.PP
Definition at line 183 of file hrectbound\&.hpp\&.
.PP
Referenced by mlpack::bound::HRectBound< Power, TakeRoot >::MinWidth()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
