.TH "src/mlpack/core/util/cli.hpp" 3 "Sat Mar 14 2015" "Version 1.0.12" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/mlpack/core/util/cli.hpp \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBmlpack::CLI\fP"
.br
.RI "\fIParses the command line for parameters and holds user-specified parameters\&. \fP"
.ti -1c
.RI "struct \fBmlpack::ParamData\fP"
.br
.RI "\fIAids in the extensibility of \fBCLI\fP by focusing potential changes into one structure\&. \fP"
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "\fBmlpack\fP"
.br
.RI "\fILinear algebra utility functions, generally performed on matrices or vectors\&. \fP"
.ti -1c
.RI "\fBmlpack::util\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPARAM\fP(T, ID, DESC, ALIAS, DEF, REQ)"
.br
.RI "\fIDefine an input parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_DOUBLE\fP(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(double, ID, DESC, ALIAS, DEF, false)"
.br
.RI "\fIDefine a double parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_DOUBLE_REQ\fP(ID, DESC, ALIAS)"
.br
.RI "\fIDefine a required double parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_FLAG\fP(ID, DESC, ALIAS)   PARAM_FLAG_INTERNAL(ID, DESC, ALIAS);"
.br
.RI "\fIDefine a flag parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_FLOAT\fP(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(float, ID, DESC, ALIAS, DEF, false)"
.br
.RI "\fIDefine a floating-point parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_FLOAT_REQ\fP(ID, DESC, ALIAS)"
.br
.RI "\fIDefine a required floating-point parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_INT\fP(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(int, ID, DESC, ALIAS, DEF, false)"
.br
.RI "\fIDefine an integer parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_INT_REQ\fP(ID, DESC, ALIAS)   \fBPARAM\fP(int, ID, DESC, ALIAS, 0, true)"
.br
.RI "\fIDefine a required integer parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_STRING\fP(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(std::string, ID, DESC, ALIAS, DEF, false)"
.br
.RI "\fIDefine a string parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_STRING_REQ\fP(ID, DESC, ALIAS)"
.br
.RI "\fIDefine a required string parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_VECTOR\fP(T, ID, DESC, ALIAS)   \fBPARAM\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"
.br
.RI "\fIDefine a vector parameter\&. \fP"
.ti -1c
.RI "#define \fBPARAM_VECTOR_REQ\fP(T, ID, DESC, ALIAS)"
.br
.RI "\fIDefine a required vector parameter\&. \fP"
.ti -1c
.RI "#define \fBPROGRAM_INFO\fP(NAME, DESC)"
.br
.RI "\fIDocument an executable\&. \fP"
.ti -1c
.RI "#define \fBTYPENAME\fP(x)   (std::string(typeid(x)\&.name()))"
.br
.RI "\fIThe TYPENAME macro is used internally to convert a type into a string\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor:\fP
.RS 4
Matthew Amidon
.RE
.PP
This file implements the CLI subsystem which is intended to replace FX\&. This can be used more or less regardless of context\&. In the future, it might be expanded to include file I/O\&.
.PP
This file is part of mlpack 1\&.0\&.12\&.
.PP
mlpack is free software; you may redstribute it and/or modify it under the terms of the 3-clause BSD license\&. You should have received a copy of the 3-clause BSD license along with mlpack\&. If not, see http://www.opensource.org/licenses/BSD-3-Clause for more information\&. 
.PP
Definition in file \fBcli\&.hpp\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define PARAM(T, ID, DESC, ALIAS, DEF, REQ)"
\fBValue:\fP
.PP
.nf
static mlpack::util::Option<T> \\
      JOIN(JOIN(io_option_dummy_object_, __LINE__), opt) (false, DEF, ID, \
      DESC, ALIAS, REQ);
.fi
.PP
Define an input parameter\&. Don't use this function; use the other ones above that call it\&. Note that we are using the \fBLINE\fP macro for naming these actual parameters when \fBCOUNTER\fP does not exist, which is a bit of an ugly hack\&.\&.\&. but this is the preprocessor, after all\&. We don't have much choice other than ugliness\&.
.PP
\fBParameters:\fP
.RS 4
\fIT\fP Type of the parameter\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP Alias for this parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&. 
.br
\fIREQ\fP Whether or not parameter is required (boolean value)\&. 
.RE
.PP

.PP
Definition at line 349 of file cli\&.hpp\&.
.SS "#define PARAM_DOUBLE(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(double, ID, DESC, ALIAS, DEF, false)"

.PP
Define a double parameter\&. The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 138 of file cli\&.hpp\&.
.SS "#define PARAM_DOUBLE_REQ(ID, DESC, ALIAS)"
\fBValue:\fP
.PP
.nf
PARAM(double, ID, DESC, ALIAS, \
    0\&.0f, true)
.fi
.PP
Define a required double parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 259 of file cli\&.hpp\&.
.SS "#define PARAM_FLAG(ID, DESC, ALIAS)   PARAM_FLAG_INTERNAL(ID, DESC, ALIAS);"

.PP
Define a flag parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 66 of file cli\&.hpp\&.
.SS "#define PARAM_FLOAT(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(float, ID, DESC, ALIAS, DEF, false)"

.PP
Define a floating-point parameter\&. You should use PARAM_DOUBLE instead\&.
.PP
The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 114 of file cli\&.hpp\&.
.SS "#define PARAM_FLOAT_REQ(ID, DESC, ALIAS)"
\fBValue:\fP
.PP
.nf
PARAM(float, ID, DESC, ALIAS, 0\&.0f, \
    true)
.fi
.PP
Define a required floating-point parameter\&. You should probably use a double instead\&.
.PP
The parameter must then be specified on the command line with --ID=value\&. If ALIAS is equal to DEF_MOD (which is set using the \fBPROGRAM_INFO()\fP macro), the parameter can be specified with just --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 236 of file cli\&.hpp\&.
.SS "#define PARAM_INT(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(int, ID, DESC, ALIAS, DEF, false)"

.PP
Define an integer parameter\&. The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 90 of file cli\&.hpp\&.
.SS "#define PARAM_INT_REQ(ID, DESC, ALIAS)   \fBPARAM\fP(int, ID, DESC, ALIAS, 0, true)"

.PP
Define a required integer parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 212 of file cli\&.hpp\&.
.SS "#define PARAM_STRING(ID, DESC, ALIAS, DEF)   \fBPARAM\fP(std::string, ID, DESC, ALIAS, DEF, false)"

.PP
Define a string parameter\&. The parameter can then be specified on the command line with --ID=value\&. If ALIAS is equal to DEF_MOD (which is set using the \fBPROGRAM_INFO()\fP macro), the parameter can be specified with just --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 163 of file cli\&.hpp\&.
.SS "#define PARAM_STRING_REQ(ID, DESC, ALIAS)"
\fBValue:\fP
.PP
.nf
PARAM(std::string, ID, DESC, \
    ALIAS, "", true);
.fi
.PP
Define a required string parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 282 of file cli\&.hpp\&.
.SS "#define PARAM_VECTOR(T, ID, DESC, ALIAS)   \fBPARAM\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"

.PP
Define a vector parameter\&. The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 187 of file cli\&.hpp\&.
.SS "#define PARAM_VECTOR_REQ(T, ID, DESC, ALIAS)"
\fBValue:\fP
.PP
.nf
PARAM(std::vector<T>, ID, DESC, \
    ALIAS, std::vector<T>(), true);
.fi
.PP
Define a required vector parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPROGRAM_INFO()\fP
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See http://mlpack.org/trac/ticket/74 for more information\&. 
.RE
.PP

.PP
Definition at line 305 of file cli\&.hpp\&.
.SS "#define PROGRAM_INFO(NAME, DESC)"
\fBValue:\fP
.PP
.nf
static mlpack::util::ProgramDoc \
    io_programdoc_dummy_object = mlpack::util::ProgramDoc(NAME, DESC);
.fi
.PP
Document an executable\&. Only one instance of this macro should be present in your program! Therefore, use it in the main\&.cpp (or corresponding executable) in your program\&.
.PP
\fBSee Also:\fP
.RS 4
\fBmlpack::CLI\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT()\fP, \fBPARAM_DOUBLE()\fP, \fBPARAM_STRING()\fP, \fBPARAM_VECTOR()\fP, \fBPARAM_INT_REQ()\fP, \fBPARAM_DOUBLE_REQ()\fP, \fBPARAM_STRING_REQ()\fP, \fBPARAM_VECTOR_REQ()\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fINAME\fP Short string representing the name of the program\&. 
.br
\fIDESC\fP Long string describing what the program does and possibly a simple usage example\&. Newlines should not be used here; this is taken care of by CLI (however, you can explicitly specify newlines to denote new paragraphs)\&. 
.RE
.PP

.PP
Definition at line 46 of file cli\&.hpp\&.
.SS "#define TYPENAME(x)   (std::string(typeid(x)\&.name()))"

.PP
The TYPENAME macro is used internally to convert a type into a string\&. 
.PP
Definition at line 364 of file cli\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
