\section{mlpack\-:\-:neighbor\-:\-:Neighbor\-Search$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1NeighborSearch}\index{mlpack\-::neighbor\-::\-Neighbor\-Search$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$@{mlpack\-::neighbor\-::\-Neighbor\-Search$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$}}


The \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class is a template class for performing distance-\/based neighbor searches.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Neighbor\-Search} (const typename Tree\-Type\-::\-Mat \&{\bf reference\-Set}, const typename Tree\-Type\-::\-Mat \&{\bf query\-Set}, const bool {\bf naive}=false, const bool {\bf single\-Mode}=false, const Metric\-Type {\bf metric}=Metric\-Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object, passing both a query and reference dataset. \end{DoxyCompactList}\item 
{\bf Neighbor\-Search} (const typename Tree\-Type\-::\-Mat \&{\bf reference\-Set}, const bool {\bf naive}=false, const bool {\bf single\-Mode}=false, const Metric\-Type {\bf metric}=Metric\-Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object, passing only one dataset, which is used as both the query and the reference dataset. \end{DoxyCompactList}\item 
{\bf Neighbor\-Search} (Tree\-Type $\ast${\bf reference\-Tree}, Tree\-Type $\ast${\bf query\-Tree}, const typename Tree\-Type\-::\-Mat \&{\bf reference\-Set}, const typename Tree\-Type\-::\-Mat \&{\bf query\-Set}, const bool {\bf single\-Mode}=false, const Metric\-Type {\bf metric}=Metric\-Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object with the given datasets and pre-\/constructed trees. \end{DoxyCompactList}\item 
{\bf Neighbor\-Search} (Tree\-Type $\ast${\bf reference\-Tree}, const typename Tree\-Type\-::\-Mat \&{\bf reference\-Set}, const bool {\bf single\-Mode}=false, const Metric\-Type {\bf metric}=Metric\-Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object with the given reference dataset and pre-\/constructed tree. \end{DoxyCompactList}\item 
{\bf $\sim$\-Neighbor\-Search} ()
\begin{DoxyCompactList}\small\item\em Delete the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object. \end{DoxyCompactList}\item 
void {\bf Search} (const size\-\_\-t k, arma\-::\-Mat$<$ size\-\_\-t $>$ \&resulting\-Neighbors, arma\-::mat \&distances)
\begin{DoxyCompactList}\small\item\em Compute the nearest neighbors and store the output in the given matrices. \end{DoxyCompactList}\item 
std\-::string {\bf To\-String} () const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
bool {\bf has\-Query\-Set}
\begin{DoxyCompactList}\small\item\em Indicates if a separate query set was passed. \end{DoxyCompactList}\item 
Metric\-Type {\bf metric}
\begin{DoxyCompactList}\small\item\em Instantiation of metric. \end{DoxyCompactList}\item 
bool {\bf naive}
\begin{DoxyCompactList}\small\item\em Indicates if O(n$^\wedge$2) naive search is being used. \end{DoxyCompactList}\item 
std\-::vector$<$ size\-\_\-t $>$ {\bf old\-From\-New\-Queries}
\begin{DoxyCompactList}\small\item\em Permutations of query points during tree building. \end{DoxyCompactList}\item 
std\-::vector$<$ size\-\_\-t $>$ {\bf old\-From\-New\-References}
\begin{DoxyCompactList}\small\item\em Permutations of reference points during tree building. \end{DoxyCompactList}\item 
Tree\-Type\-::\-Mat {\bf query\-Copy}
\begin{DoxyCompactList}\small\item\em Copy of query dataset (if we need it, because tree building modifies it). \end{DoxyCompactList}\item 
const Tree\-Type\-::\-Mat \& {\bf query\-Set}
\begin{DoxyCompactList}\small\item\em Query dataset (may not be given). \end{DoxyCompactList}\item 
Tree\-Type $\ast$ {\bf query\-Tree}
\begin{DoxyCompactList}\small\item\em Pointer to the root of the query tree (might not exist). \end{DoxyCompactList}\item 
Tree\-Type\-::\-Mat {\bf reference\-Copy}
\begin{DoxyCompactList}\small\item\em Copy of reference dataset (if we need it, because tree building modifies it). \end{DoxyCompactList}\item 
const Tree\-Type\-::\-Mat \& {\bf reference\-Set}
\begin{DoxyCompactList}\small\item\em Reference dataset. \end{DoxyCompactList}\item 
Tree\-Type $\ast$ {\bf reference\-Tree}
\begin{DoxyCompactList}\small\item\em Pointer to the root of the reference tree. \end{DoxyCompactList}\item 
bool {\bf single\-Mode}
\begin{DoxyCompactList}\small\item\em Indicates if single-\/tree search is being used (opposed to dual-\/tree). \end{DoxyCompactList}\item 
bool {\bf tree\-Owner}
\begin{DoxyCompactList}\small\item\em If true, this object created the trees and is responsible for them. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$class mlpack\-::neighbor\-::\-Neighbor\-Search$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$}

The \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class is a template class for performing distance-\/based neighbor searches. 

It takes a query dataset and a reference dataset (or just a reference dataset) and, for each point in the query dataset, finds the k neighbors in the reference dataset which have the 'best' distance according to a given sorting policy. A constructor is given which takes only a reference dataset, and if that constructor is used, the given reference dataset is also used as the query dataset.

The template parameters Sort\-Policy and Metric define the sort function used and the metric (distance function) used. More information on those classes can be found in the \doxyref{Nearest\-Neighbor\-Sort}{p.}{classmlpack_1_1neighbor_1_1NearestNeighborSort} class and the \doxyref{kernel\-::\-Example\-Kernel}{p.}{classmlpack_1_1kernel_1_1ExampleKernel} class.


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\-Policy} & The sort policy for distances; see \doxyref{Nearest\-Neighbor\-Sort}{p.}{classmlpack_1_1neighbor_1_1NearestNeighborSort}. \\
\hline
{\em Metric\-Type} & The metric to use for computation. \\
\hline
{\em Tree\-Type} & The tree type to use. \\
\hline
\end{DoxyTemplParams}


Definition at line 55 of file neighbor\-\_\-search.\-hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!Neighbor\-Search@{Neighbor\-Search}}
\index{Neighbor\-Search@{Neighbor\-Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{Neighbor\-Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::{\bf Neighbor\-Search} (
\begin{DoxyParamCaption}
\item[{const typename Tree\-Type\-::\-Mat \&}]{reference\-Set, }
\item[{const typename Tree\-Type\-::\-Mat \&}]{query\-Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\-Mode = {\ttfamily false}, }
\item[{const Metric\-Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_af4c7181b4b956a4045925a17302d9705}


Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object, passing both a query and reference dataset. 

Optionally, perform the computation in naive mode or single-\/tree mode, and set the leaf size used for tree-\/building. An initialized distance metric can be given, for cases where the metric has internal data (i.\-e. the distance\-::\-Mahalanobis\-Distance class).

This method will copy the matrices to internal copies, which are rearranged during tree-\/building. You can avoid this extra copy by pre-\/constructing the trees and passing them using a diferent constructor.


\begin{DoxyParams}{Parameters}
{\em reference\-Set} & Set of reference points. \\
\hline
{\em query\-Set} & Set of query points. \\
\hline
{\em naive} & If true, O(n$^\wedge$2) naive search will be used (as opposed to dual-\/tree search). This overrides single\-Mode (if it is set to true). \\
\hline
{\em single\-Mode} & If true, single-\/tree search will be used (as opposed to dual-\/tree search). \\
\hline
{\em leaf\-Size} & Leaf size for tree construction (ignored if tree is given). \\
\hline
{\em metric} & An optional instance of the Metric\-Type class. \\
\hline
\end{DoxyParams}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!Neighbor\-Search@{Neighbor\-Search}}
\index{Neighbor\-Search@{Neighbor\-Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{Neighbor\-Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::{\bf Neighbor\-Search} (
\begin{DoxyParamCaption}
\item[{const typename Tree\-Type\-::\-Mat \&}]{reference\-Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\-Mode = {\ttfamily false}, }
\item[{const Metric\-Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_af3758b7e677320db323412ae45fd5b19}


Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object, passing only one dataset, which is used as both the query and the reference dataset. 

Optionally, perform the computation in naive mode or single-\/tree mode, and set the leaf size used for tree-\/building. An initialized distance metric can be given, for cases where the metric has internal data (i.\-e. the distance\-::\-Mahalanobis\-Distance class).

If naive mode is being used and a pre-\/built tree is given, it may not work\-: naive mode operates by building a one-\/node tree (the root node holds all the points). If that condition is not satisfied with the pre-\/built tree, then naive mode will not work.


\begin{DoxyParams}{Parameters}
{\em reference\-Set} & Set of reference points. \\
\hline
{\em naive} & If true, O(n$^\wedge$2) naive search will be used (as opposed to dual-\/tree search). This overrides single\-Mode (if it is set to true). \\
\hline
{\em single\-Mode} & If true, single-\/tree search will be used (as opposed to dual-\/tree search). \\
\hline
{\em leaf\-Size} & Leaf size for tree construction (ignored if tree is given). \\
\hline
{\em metric} & An optional instance of the Metric\-Type class. \\
\hline
\end{DoxyParams}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!Neighbor\-Search@{Neighbor\-Search}}
\index{Neighbor\-Search@{Neighbor\-Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{Neighbor\-Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::{\bf Neighbor\-Search} (
\begin{DoxyParamCaption}
\item[{Tree\-Type $\ast$}]{reference\-Tree, }
\item[{Tree\-Type $\ast$}]{query\-Tree, }
\item[{const typename Tree\-Type\-::\-Mat \&}]{reference\-Set, }
\item[{const typename Tree\-Type\-::\-Mat \&}]{query\-Set, }
\item[{const bool}]{single\-Mode = {\ttfamily false}, }
\item[{const Metric\-Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a3805a20e00426043b633fb5dd95f0a63}


Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object with the given datasets and pre-\/constructed trees. 

It is assumed that the points in reference\-Set and query\-Set correspond to the points in reference\-Tree and query\-Tree, respectively. Optionally, choose to use single-\/tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, construct a tree with all of the points in one leaf (i.\-e. leaf\-Size = number of points). Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.

There is no copying of the data matrices in this constructor (because tree-\/building is not necessary), so this is the constructor to use when copies absolutely must be avoided.

\begin{DoxyNote}{Note}
Because tree-\/building (at least with Binary\-Space\-Tree) modifies the ordering of a matrix, be sure you pass the modified matrix to this object! In addition, mapping the points of the matrix back to their original indices is not done when this constructor is used. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em reference\-Tree} & Pre-\/built tree for reference points. \\
\hline
{\em query\-Tree} & Pre-\/built tree for query points. \\
\hline
{\em reference\-Set} & Set of reference points corresponding to reference\-Tree. \\
\hline
{\em query\-Set} & Set of query points corresponding to query\-Tree. \\
\hline
{\em single\-Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!Neighbor\-Search@{Neighbor\-Search}}
\index{Neighbor\-Search@{Neighbor\-Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{Neighbor\-Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::{\bf Neighbor\-Search} (
\begin{DoxyParamCaption}
\item[{Tree\-Type $\ast$}]{reference\-Tree, }
\item[{const typename Tree\-Type\-::\-Mat \&}]{reference\-Set, }
\item[{const bool}]{single\-Mode = {\ttfamily false}, }
\item[{const Metric\-Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a24bad65aaf659db59982ef321663133c}


Initialize the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object with the given reference dataset and pre-\/constructed tree. 

It is assumed that the points in reference\-Set correspond to the points in reference\-Tree. Optionally, choose to use single-\/tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, construct a tree with all the points in one leaf (i.\-e. leaf\-Size = number of points). Additionally, an instantiated distance metric can be given, for the case where the distance metric holds data.

There is no copying of the data matrices in this constructor (because tree-\/building is not necessary), so this is the constructor to use when copies absolutely must be avoided.

\begin{DoxyNote}{Note}
Because tree-\/building (at least with Binary\-Space\-Tree) modifies the ordering of a matrix, be sure you pass the modified matrix to this object! In addition, mapping the points of the matrix back to their original indices is not done when this constructor is used. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em reference\-Tree} & Pre-\/built tree for reference points. \\
\hline
{\em reference\-Set} & Set of reference points corresponding to reference\-Tree. \\
\hline
{\em single\-Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!$\sim$\-Neighbor\-Search@{$\sim$\-Neighbor\-Search}}
\index{$\sim$\-Neighbor\-Search@{$\sim$\-Neighbor\-Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{$\sim$\-Neighbor\-Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::$\sim${\bf Neighbor\-Search} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_afa11870eb010fc3e4ccbcfe0228e1eec}


Delete the \doxyref{Neighbor\-Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} object. 

The tree is the only member we are responsible for deleting. The others will take care of themselves. 

\subsection{Member Function Documentation}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!Search@{Search}}
\index{Search@{Search}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{Search}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ void {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::Search (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{k, }
\item[{arma\-::\-Mat$<$ size\-\_\-t $>$ \&}]{resulting\-Neighbors, }
\item[{arma\-::mat \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a8cf6b783caa2e44a38c00662726b2987}


Compute the nearest neighbors and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em k} & Number of neighbors to search for. \\
\hline
{\em resulting\-Neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!To\-String@{To\-String}}
\index{To\-String@{To\-String}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{To\-String}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ std\-::string {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::To\-String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1neighbor_1_1NeighborSearch_aabc82a104e5e808106b6c0807ad1aca6}


\subsection{Member Data Documentation}
\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!has\-Query\-Set@{has\-Query\-Set}}
\index{has\-Query\-Set@{has\-Query\-Set}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{has\-Query\-Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ bool {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::has\-Query\-Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_adf6e28ad055b792f609820806ddf25d3}


Indicates if a separate query set was passed. 



Definition at line 224 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!metric@{metric}}
\index{metric@{metric}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ Metric\-Type {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a5792bd75879b8a7586ff6eb992044ad7}


Instantiation of metric. 



Definition at line 232 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!naive@{naive}}
\index{naive@{naive}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{naive}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ bool {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::naive\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_aa40c742a9d1c8b7872f93178821d1234}


Indicates if O(n$^\wedge$2) naive search is being used. 



Definition at line 227 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!old\-From\-New\-Queries@{old\-From\-New\-Queries}}
\index{old\-From\-New\-Queries@{old\-From\-New\-Queries}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{old\-From\-New\-Queries}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ std\-::vector$<$size\-\_\-t$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::old\-From\-New\-Queries\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_abe76db0eef4e45a015f62e2d5e98d573}


Permutations of query points during tree building. 



Definition at line 237 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!old\-From\-New\-References@{old\-From\-New\-References}}
\index{old\-From\-New\-References@{old\-From\-New\-References}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{old\-From\-New\-References}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ std\-::vector$<$size\-\_\-t$>$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::old\-From\-New\-References\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a8539f88794be5ce6e25b200c8ae574dd}


Permutations of reference points during tree building. 



Definition at line 235 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!query\-Copy@{query\-Copy}}
\index{query\-Copy@{query\-Copy}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{query\-Copy}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ Tree\-Type\-::\-Mat {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::query\-Copy\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_aa10110d6c112f21bb1a7df6a5ddb9231}


Copy of query dataset (if we need it, because tree building modifies it). 



Definition at line 209 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!query\-Set@{query\-Set}}
\index{query\-Set@{query\-Set}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{query\-Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ const Tree\-Type\-::\-Mat\& {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::query\-Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a305d01265f6270589b23379518fbc665}


Query dataset (may not be given). 



Definition at line 214 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!query\-Tree@{query\-Tree}}
\index{query\-Tree@{query\-Tree}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{query\-Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ Tree\-Type$\ast$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::query\-Tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a72ea1026cb738c052d7dba9c2a015038}


Pointer to the root of the query tree (might not exist). 



Definition at line 219 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!reference\-Copy@{reference\-Copy}}
\index{reference\-Copy@{reference\-Copy}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{reference\-Copy}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ Tree\-Type\-::\-Mat {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::reference\-Copy\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a16cba0b21f9ebea03b8139c420597a96}


Copy of reference dataset (if we need it, because tree building modifies it). 



Definition at line 207 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!reference\-Set@{reference\-Set}}
\index{reference\-Set@{reference\-Set}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{reference\-Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ const Tree\-Type\-::\-Mat\& {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::reference\-Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a332b9acf9a4ffaa8a1e9fc0542f98a8e}


Reference dataset. 



Definition at line 212 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!reference\-Tree@{reference\-Tree}}
\index{reference\-Tree@{reference\-Tree}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{reference\-Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ Tree\-Type$\ast$ {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::reference\-Tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_aeeff53562a71149eadd61198139b41bf}


Pointer to the root of the reference tree. 



Definition at line 217 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!single\-Mode@{single\-Mode}}
\index{single\-Mode@{single\-Mode}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{single\-Mode}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ bool {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::single\-Mode\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a70e4c04b4ec4437e286ff4771048c646}


Indicates if single-\/tree search is being used (opposed to dual-\/tree). 



Definition at line 229 of file neighbor\-\_\-search.\-hpp.

\index{mlpack\-::neighbor\-::\-Neighbor\-Search@{mlpack\-::neighbor\-::\-Neighbor\-Search}!tree\-Owner@{tree\-Owner}}
\index{tree\-Owner@{tree\-Owner}!mlpack::neighbor::NeighborSearch@{mlpack\-::neighbor\-::\-Neighbor\-Search}}
\subsubsection[{tree\-Owner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\-Policy = Nearest\-Neighbor\-Sort, typename Metric\-Type = mlpack\-::metric\-::\-Squared\-Euclidean\-Distance, typename Tree\-Type = tree\-::\-Binary\-Space\-Tree$<$bound\-::\-H\-Rect\-Bound$<$2$>$,             Neighbor\-Search\-Stat$<$\-Sort\-Policy$>$ $>$$>$ bool {\bf mlpack\-::neighbor\-::\-Neighbor\-Search}$<$ Sort\-Policy, Metric\-Type, Tree\-Type $>$\-::tree\-Owner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1NeighborSearch_a837e1ce91f292f9ff51ce33666cbbb94}


If true, this object created the trees and is responsible for them. 



Definition at line 222 of file neighbor\-\_\-search.\-hpp.



The documentation for this class was generated from the following file\-:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/neighbor\-\_\-search/{\bf neighbor\-\_\-search.\-hpp}\end{DoxyCompactItemize}
